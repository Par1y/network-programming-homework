<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>NoMeeting æ§åˆ¶å°</title>
	<link rel="stylesheet" href="https://unpkg.com/antd/dist/reset.css" />
	<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
	<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
	<script src="https://unpkg.com/dayjs/dayjs.min.js"></script>
	<script src="https://unpkg.com/antd/dist/antd.js"></script>
	<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
	<style>
		.ant-layout-header {
			background: #fff;
			padding: 0 24px;
			border-bottom: 1px solid #f0f0f0;
		}
		.logo {
			font-size: 20px;
			font-weight: 600;
		}
		.ant-layout-content {
			padding: 24px;
			min-height: calc(100vh - 64px - 70px);
		}
		.ant-layout-footer {
			text-align: center;
		}
		.stream-card img {
			width: 100%;
			height: 100%;
			object-fit: contain;
			background: #000;
		}
		.stream-card .ant-card-body {
			padding: 0;
			position: relative;
			aspect-ratio: 16 / 9;
		}
		.stream-card audio {
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			opacity: 0.7;
		}
		.stream-placeholder {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			text-align: center;
			color: #888;
		}
	</style>
</head>
<body>
	<div id="root"></div>

	<script type="text/babel">
		const { useState, useEffect, useRef } = React;
		const {
			Layout,
			Button,
			Input,
			Form,
			Row,
			Col,
			Card,
			Modal,
			Spin,
			Empty,
			Tag,
			message,
			Typography,
			Space,
			Grid,
		} = antd;
		const { Header, Content, Footer } = Layout;
		const { Title } = Typography;
		const { useBreakpoint } = Grid;

		const App = () => {
			const [form] = Form.useForm();
			const [connected, setConnected] = useState(false);
			const [loading, setLoading] = useState(false);
			const [streams, setStreams] = useState([]);
			const [status, setStatus] = useState({ text: 'æœªè¿æ¥', color: 'default' });
			const intervalRef = useRef(null);
			const screens = useBreakpoint();

			const handleConnect = async (values) => {
				setLoading(true);
				setStatus({ text: 'è¿æ¥ä¸­...', color: 'processing' });
				try {
					const response = await fetch('/api/connect', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(values),
					});
					const data = await response.json();

					if (response.ok && data.success) {
						message.success('è¿æ¥æˆåŠŸ!');
						setConnected(true);
						setStatus({ text: `å·²è¿æ¥åˆ° ${values.room_name}`, color: 'success' });
						startFetchingStreams();
					} else {
						throw new Error(data.message || 'è¿æ¥å¤±è´¥');
					}
				} catch (error) {
					message.error(`è¿æ¥å¤±è´¥: ${error.message}`);
					setStatus({ text: 'è¿æ¥å¤±è´¥', color: 'error' });
				} finally {
					setLoading(false);
				}
			};

			const handleDisconnect = async () => {
				setLoading(true);
				setStatus({ text: 'æ–­å¼€ä¸­...', color: 'processing' });
				try {
					const response = await fetch('/api/disconnect', { method: 'POST' });
					const data = await response.json();
					if (response.ok && data.success) {
						message.success('å·²æ–­å¼€è¿æ¥');
						setConnected(false);
						setStreams([]);
						setStatus({ text: 'æœªè¿æ¥', color: 'default' });
						if (intervalRef.current) {
							clearInterval(intervalRef.current);
							intervalRef.current = null;
						}
					} else {
						throw new Error(data.message || 'æ–­å¼€è¿æ¥å¤±è´¥');
					}
				} catch (error) {
					message.error(`æ–­å¼€è¿æ¥å¤±è´¥: ${error.message}`);
					// Keep status as connected if disconnect fails
					setStatus({ text: 'æ–­å¼€å¤±è´¥', color: 'error' });
				} finally {
					setLoading(false);
				}
			};
			
			const fetchStreams = async () => {
				if (!document.hidden) { // Only fetch if tab is visible
					try {
						const response = await fetch('/api/streams');
						if (!response.ok) {
							// If API fails, maybe connection is lost
							if(response.status >= 500) {
								console.error('æœåŠ¡å™¨é”™è¯¯ï¼Œå¯èƒ½è¿æ¥å·²æ–­å¼€');
								handleDisconnect(); // Attempt to clean up state
							}
							return;
						};
						const data = await response.json();
						if (data.success) {
							setStreams(data.streams || []);
						}
					} catch (error) {
						console.error('è·å–æµåˆ—è¡¨å¤±è´¥:', error);
						// This might happen if the server is down, treat as disconnected
						handleDisconnect();
					}
				}
			};

			const startFetchingStreams = () => {
				fetchStreams(); // Initial fetch
				if (intervalRef.current) clearInterval(intervalRef.current);
				intervalRef.current = setInterval(fetchStreams, 5000);
			};

			useEffect(() => {
				return () => {
					if (intervalRef.current) {
						clearInterval(intervalRef.current);
					}
				};
			}, []);

			const StreamCard = ({ stream }) => {
				const { id, type } = stream;
				const [error, setError] = useState(false);

				useEffect(() => {
					setError(false);
				}, [id]);

				const renderContent = () => {
					if (error) {
						return (
							<div className="stream-placeholder">
								<p>âŒ åŠ è½½å¤±è´¥</p>
							</div>
						);
					}

					if (type === 'video') {
						return (
							<img
								src={`/stream/${id}`}
								alt={`è§†é¢‘æµ ${id}`}
								onError={() => setError(true)}
							/>
						);
					}

					if (type === 'audio') {
						return (
							<>
								<div className="stream-placeholder">
									<p>ğŸ¤ ä»…éŸ³é¢‘</p>
								</div>
								<audio
									src={`/audio/${id}`}
									autoPlay
									controls
									onError={() => setError(true)}
								/>
							</>
						);
					}
					return null;
				};

				return (
					<Col xs={24} sm={24} md={12} lg={8} xl={6}>
						<Card
							className="stream-card"
							title={`${type === 'video' ? 'ğŸ“¹' : 'ğŸ¤'} åª’ä½“æµ #${id}`}
							hoverable
						>
							{renderContent()}
						</Card>
					</Col>
				);
			};

			return (
				<Layout>
					<Header>
						<Row justify="space-between" align="middle">
							<Col>
								<Title level={3} style={{ color: '#1890ff', margin: 0 }}>ğŸ¥ NoMeeting</Title>
							</Col>
							<Col>
								<Space>
									<Tag color={status.color}>{status.text}</Tag>
									{!connected ? (
										<Button type="primary" onClick={() => form.submit()} loading={loading}>
											è¿æ¥
										</Button>
									) : (
										<Button danger onClick={handleDisconnect} loading={loading}>
											æ–­å¼€è¿æ¥
										</Button>
									)}
								</Space>
							</Col>
						</Row>
					</Header>
					<Content>
						{!connected ? (
							<Row justify="center" align="middle" style={{ height: '100%' }}>
								<Col xs={24} sm={18} md={12} lg={8}>
									<Card title="åŠ å…¥ä¼šè®®">
										<Form
											form={form}
											layout="vertical"
											onFinish={handleConnect}
											initialValues={{
												server_ws: 'ws://localhost:3001',
												room_name: 'testroom',
											}}
										>
											<Form.Item
												name="server_ws"
												label="æœåŠ¡å™¨åœ°å€"
												rules={[{ required: true, message: 'è¯·è¾“å…¥WebSocketæœåŠ¡å™¨åœ°å€' }]}
											>
												<Input placeholder="e.g., ws://localhost:3001" />
											</Form.Item>
											<Form.Item
												name="room_name"
												label="æˆ¿é—´å"
												rules={[{ required: true, message: 'è¯·è¾“å…¥æˆ¿é—´å' }]}
											>
												<Input placeholder="e.g., testroom" />
											</Form.Item>
										</Form>
									</Card>
								</Col>
							</Row>
						) : (
							<Spin spinning={loading && streams.length === 0}>
								{streams.length > 0 ? (
									<Row gutter={[16, 16]}>
										{streams.map(stream => <StreamCard key={stream.id} stream={stream} />)}
									</Row>
								) : (
									<Empty description="æš‚æ— å¯ç”¨çš„è§†é¢‘æµ" />
								)}
							</Spin>
						)}
					</Content>
					<Footer>NoMeeting Â©2024 Created with Ant Design</Footer>
				</Layout>
			);
		};

		const container = document.getElementById('root');
		const root = ReactDOM.createRoot(container);
		root.render(<App />);
	</script>
</body>
</html>